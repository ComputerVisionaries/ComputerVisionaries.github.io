<!DOCTYPE html>
<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Computer Vision Class Project | CS, Gatech | Fall 2018: CS 4476</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

<!-- Le styles -->
  <link href="css/bootstrap.css" rel="stylesheet">
<style>
body {
padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
}
.vis {
color: #3366CC;
}
.data {
color: #FF9900;
}
</style>

<link href="css/bootstrap-responsive.min.css" rel="stylesheet">

<!-- HTML5 shim, for IE6-8 support of HTML5 elements --><!--[if lt IE 9]>
<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
</head>

<body>
<div class="container">
<div class="page-header">

<!-- Title and Name -->
<h1>Jigsaw Puzzle Solver</h1>
<span style="font-size: 20px; line-height: 1.5em;"><strong>The Computer Visionaries</strong></span><br>
<span style="font-size: 18px; line-height: 1.5em;">CS 4476 : Intro to Computer Vision</span><br>
<span style="font-size: 18px; line-height: 1.5em;">Georgia Tech</span>
<span style="font-size: 18px; line-height: 1.5em;">Fall 2018</span><br>
<span style="font-size: 18px; line-height: 1.5em;">Final Project</span><br>
<hr>

<h1><strong>Proposal</strong></h1>
<h2><strong>Problem Statement</strong></h2>
<br>

<h3><i>Project Goal</i></h3>
We wish to develop a fast, robust, and accurate jigsaw puzzle solver.
<br><br>

The idea for this project was inspired by the work of Sholomon, David, & Netanyahu [1], as well as T. Allen [2].
<br><br>

Sholomon et al. demonstrate how genetic algorithms can solve digital square jigsaw puzzles.
Allen's paper focuses on solving simple physical puzzles with non-square shapes using image processing techniques.
<br><br>

Sholmon et al.'s method was shown to work on large puzzles (+20,000 pieces) but is fragile.
Their algorithm ignores situations where any of the pieces are missing, rotated, or damaged.
As well, their system only works on images, and was not shown to work on physical jigsaw puzzles.
<br><br>

Allen's method was shown to work on restricted physical puzzles.
The examples givin in his paper are of small jigsaw puzzles (fewer than 20 pieces).
His system demonstrates flexibility in its ability to solve the puzzle when the input pieces are rotated or jumbled.
Finally, Allen's algorithm failed to show to combined pieces put together (it just showed compatible pieces next to each other)
<br><br>

Using the above techniques, we wish to derive our own algorithm for puzzle assembly considering increasingly more complex piece shapes and rotations.
<br><br>

<h3><i>Input</i></h3>
An image of a jigsaw puzzle that follows the bellow assumptions.<br><br>

Assumptions
<ul>
  <li> All pieces are facing upwards </li>
  <li> All piece edges are clearly visible </li>
  <li> The background is a solid color </li>
  <li> All pieces are distinguishable from the background </li>
</ul>

<br>
<img style="height: 300px;" alt="" src="imgs/Example_Input.PNG">
<br>
<i> Figure 1 : Example input image for our system taken from [2]</i>
<br>

<h3><i>Output</i></h3>
A solved jigsaw puzzle image
<br>
<img style="height: 300px;" alt="" src="imgs/Example_Output.PNG">
<br>
<i> Figure 2 : Example output image for our system taken from [2]</i>
<br>

<h3><i>Real World Application</i></h3>
While we chose this project mostly out of intellectual curiosity,
there are some practical applications that can be derived out of optimal puzzle reconstruction.
For instance, optimal piece reconstruction can possibly be used towards automatic piecing-together of archeological finds,
which can help quickly determine if any pieces are missing, or to stitch back together a shredded document or picture.
In addition, these techniques might be useful for optimal part alignments in some engineering applications.
Therefore, this work could serve some extrinsic purposes beside just solving puzzles.
<br><br>

<h2><strong>Approach</strong></h2>
Development will occure in 2 Phases
<ul>
  <li>Phase 1 : Add flexibility to existing square jigsaw solvers</li>
  <li>Phase 2 : Convert physical jigsaw images into digital square jigsaw ones</li>
</ul>

<h3><i>Phase 1</i></h3>
We have identified several algorithms as candidates for our puzzle solver.
We plan on running these algorithms on the simple square jigsaw puzzles (no rotation, or non-square pieces) and compare their performance.
<br><br>

One existing algorithm we will be evaluating is a genetic algorithm from the work by Sholomon et al. [1].
As stated in the paper, the problem is formulated as:
“Given n different non-overlapping pieces of an image,
the player has to reconstruct the original image,
taking advantage of both the shape and chromatic information of each piece.”
Note that rotation is not part of the problem.
The algorithm frames puzzle configurations as members of a population and uses a metric for dissimilarity between neighboring pieces as its fitness function.
Then, they apply a classic genetic optimization technique, performing mutations and crossovers amongst the most fit members of the population.
After applying the algorithm as described in the paper, we will build upon their genetic algorithm by substituting different fitness metrics and crossover operators.
<br><br>

Another algorithm we will apply is introduced by Gallagher [3].
Unlike Sholomon et al., which applies a standard optimization algorithm, Gallagher presents a novel technique where the puzzle is represented as a graph.
This approach does take into account the spatial orientation of pieces.
Pieces are represented as vertices and edge weights between pieces on the graph represent the output of a dissimilarity metric estimating the difference in color gradients between neighboring pieces.
Then, a version of Kruskal’s minimum spanning tree algorithm, modified to account for spatial conflicts between pieces, is applied to the graph.
The resulting tree represents a puzzle configuration that greedily minimizes dissimilarity between neighboring pieces.
Algorithm performance could be tuned by substituting the dissimilarity metric.
<br><br>

Based on the success of standard discrete optimization techniques in Sholomon et al.,
we can apply other discrete optimization algorithms using similar fitness/cost metrics without much modification.
Other algorithms we might apply seeking better performance include simulated annealing, random hill climbing, and estimation of distribution algorithms such as MIMIC.
Because implementations of these optimization algorithms are already readily available in libraries like Scikit-Learn,
applying each technique to the standard square jigsaw problem will require little implementation.
<br><br>

After our initial algorithm selection from the candidates, we will modify the selected algorithm to handle rotated puzzle pieces.
Once we have achieved success in assembling square jigsaw puzzles with rotations, we will again modify the algorithm to handle non-square pieces.

<h3><i>Phase 2</i></h3>


<br><br>


<h2><strong>Experiments and Results</strong></h2>
<h3><i>Resources</i></h3>
<h3><i>Datasets</i></h3>
<h3><i>External Code Bases</i></h3>
<h3><i>Internal Code Base</i></h3>
<h3><i>Success Parameters</i></h3>
<h3><i>Experiments</i></h3>


<br><br>
  <hr>
  <footer>
  <p>© The Computer Visionaries</p>
  </footer>
</div>
</div>

<br><br>

</body></html>
